<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>graphics on graeme phillips posting</title><link>https://graemephi.github.io/tags/graphics/</link><description>Recent content in graphics on graeme phillips posting</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 20 May 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://graemephi.github.io/tags/graphics/index.xml" rel="self" type="application/rss+xml"/><item><title>i made a twitter bot: deep sky object</title><link>https://graemephi.github.io/posts/deep-sky-object/</link><pubDate>Wed, 20 May 2020 00:00:00 +0000</pubDate><guid>https://graemephi.github.io/posts/deep-sky-object/</guid><description>&lt;p>A couple months ago I set &lt;a href="https://twitter.com/tiny_dso">@tiny_dso&lt;/a> running. It&amp;rsquo;s a twitter art bot, which I guess is less of an exciting thing nowadays, but it&amp;rsquo;s an idea I&amp;rsquo;ve wanted to do for at least a few years now: turn &lt;a href="https://twitter.com/tiny_star_field">@tiny_star_field&lt;/a>'s tweets into computer generated imitations of astrophotography.&lt;/p>
&lt;p>tiny_star_field is getting a bit intermittent nowadays, so I set the bot to work it&amp;rsquo;s way backwards through tiny_star_field's old tweets. I wanted to make it something you could follow for a long time and still be surprised by, rather than something you&amp;rsquo;d scroll down once and see everything it&amp;rsquo;s capable of. We&amp;rsquo;ll see if I succeeded there; I&amp;rsquo;m not sure. It&amp;rsquo;s hard to tweak the parameters for that kind of thing, especially since when I&amp;rsquo;m working on it I generate hundreds of images, which skews my perception of what&amp;rsquo;s happening too much or not enough.&lt;/p>
&lt;p>It&amp;rsquo;s been running for a while, so I can let it speak for itself:&lt;/p>
&lt;div class="img-flex">
&lt;img src="https://graemephi.github.io/posts/deep-sky-object/EXeYst0XkAITLkB.png" width="480" height="480" />
&lt;img src="https://graemephi.github.io/posts/deep-sky-object/ERjccJlXYAEwypn.png" width="480" height="480" />
&lt;img src="https://graemephi.github.io/posts/deep-sky-object/ESHpGWuW4AEAUlJ.png" width="480" height="480" />
&lt;img src="https://graemephi.github.io/posts/deep-sky-object/ETJqBfgWoAIiTNk.png" width="480" height="480" />
&lt;img src="https://graemephi.github.io/posts/deep-sky-object/EShIIcjXQAEHntm.png" width="480" height="480" />
&lt;img src="https://graemephi.github.io/posts/deep-sky-object/EW0CH6_WkAQaKBw.png" width="480" height="480" />
&lt;/div>
&lt;p>I don&amp;rsquo;t have it in me to write more about it with a coherent structure so I&amp;rsquo;m just going to dump some notes on the implementation here. I wrote most of the code a couple years ago, returned to it a couple times, and really just decided to get it running on twitter recently. There&amp;rsquo;s probably some stuff I intended to do that I&amp;rsquo;ve completely forgotten about, so this is mostly technical details I can read out of the code.&lt;/p>
&lt;hr>
&lt;p>The bot part that talks to twitter is just javascript that lives on &lt;a href="https://tiny-dso.glitch.me/">glitch&lt;/a>. The &lt;a href="https://github.com/graemephi/starfield">image generator&lt;/a> is an executable that spits pngs out of standard out.&lt;/p>
&lt;hr>
&lt;p>It&amp;rsquo;s written in ion, the language Per Vognsen created for &lt;a href="https://github.com/pervognsen/bitwise">bitwise&lt;/a>. It&amp;rsquo;s basically C99, except you can omit type names sometimes, you use &lt;code>.&lt;/code> instead of &lt;code>-&amp;gt;&lt;/code>, and there is some notion of modules. Oh, and it has out of order declarations. I think when I started writing this the language was fully 2 weeks old. It looked pretty cool and I didn&amp;rsquo;t want to use any libraries in this project&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>, so it fit my needs fine. As new and unfinished compilers go, it was pretty reliable. But it didn&amp;rsquo;t receive a whole lot of development past that. Coming back to the code to get the images onto twitter I found it had some bugs to work around, mostly to do with getting it to generate code that would compile on linux&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>.&lt;/p>
&lt;p>I found tweaking the image generation intolerable if it took more than half a second or so, so I spent some time optimising it. That means multi-threading, vector instructions, and a lot of profiling. This wasn&amp;rsquo;t a problem with ion, because it can generate C code, and will take your word for it if you tell it some function or type exists. Also, it uses the C preprocessor to get line information to debuggers (and profilers). All in all, very nice. Good language.&lt;/p>
&lt;hr>
&lt;p>I learned early on that the easiest way to render a passable looking star was to place a single white pixel on an otherwise blank texture and just use &lt;a href="https://graemephi.github.io/posts/calculating-lod/">mipmaps&lt;/a> to filter it for rendering. Rotating a shrunken, very bright, pixel gets you endless variation on how the stars look.&lt;/p>
&lt;p>Pixel values fall in the range &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mo stretchy="false">[&lt;/mo>&lt;mn>0&lt;/mn>&lt;mo separator="true">,&lt;/mo>&lt;mn>1&lt;/mn>&lt;mo stretchy="false">]&lt;/mo>&lt;/mrow>&lt;annotation encoding="application/x-tex">[0, 1]&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:1em;vertical-align:-0.25em;">&lt;/span>&lt;span class="mopen">[&lt;/span>&lt;span class="mord">0&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="mord">1&lt;/span>&lt;span class="mclose">]&lt;/span>&lt;/span>&lt;/span>&lt;/span> and, if you think on it, stars really ought to be much brighter than that. So this method works best if you just let your values overflow then adaptively crunch the image back down with post-processing. Most astrophotography has gone through reams of processing, anyway.&lt;/p>
&lt;hr>
&lt;p>All the &amp;ldquo;pixel shader&amp;rdquo;-like work is done using a pair of functions, &lt;code>pixel_iter_begin&lt;/code> and &lt;code>pixel_iter_next&lt;/code>. Rather than explaining what they do, here&amp;rsquo;s the code for drawing a texture:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">func &lt;span style="color:#a6e22e">draw_tex&lt;/span>(dest: Image&lt;span style="color:#f92672">*&lt;/span>, target: Rect, tex: Tex&lt;span style="color:#f92672">*&lt;/span>) {
lod :&lt;span style="color:#f92672">=&lt;/span> compute_lod_level(dest.size, target.size, tex.size);
&lt;span style="color:#66d9ef">for&lt;/span> (it :&lt;span style="color:#f92672">=&lt;/span> pixel_iter_begin(dest, target); pixel_iter_next(&lt;span style="color:#f92672">&amp;amp;&lt;/span>it)) {
rgba :&lt;span style="color:#f92672">=&lt;/span> tex_lookup_lod(tex, it.npos, lod);
&lt;span style="color:#f92672">*&lt;/span>it.pixel &lt;span style="color:#f92672">=&lt;/span> color_blend(&lt;span style="color:#f92672">*&lt;/span>it.pixel, rgba);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This would work in C, but it&amp;rsquo;d look like &lt;code>for (PixelIter it = ...; pixel_iter_next(&amp;amp;it);) {} &lt;/code>. Note that trailing semicolon&amp;ndash;&lt;code>next&lt;/code> gets called before, not after, every iteration. Now, this way of iterating over pixels is very general and so pretty slow. It just makes doing pixel-by-pixel stuff extremely low friction to write code for. I think most programmers would reach for function pointers or generics to separate the pixel shading code from the iteration, but it&amp;rsquo;s not necessary, and a pain to actually use. It turns out that the iterator code was not performance critical at all, so the overhead didn&amp;rsquo;t matter much, and the implementation is also very naive.&lt;/p>
&lt;p>The pixel iterator also takes care of multi-threading. Here&amp;rsquo;s the definition of the &lt;code>Image&lt;/code> struct:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">struct&lt;/span> Image {
pixels: Color&lt;span style="color:#f92672">*&lt;/span>;
size: int2;
wr: WritableRegion;
stride: &lt;span style="color:#66d9ef">int&lt;/span>;
offset: &lt;span style="color:#66d9ef">int&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>WritableRegion&lt;/code> allows the pixel iterator to clip the pixels being iterated over to the block the thread is responsible for rendering. The code that actually uses the pixel iterator doesn&amp;rsquo;t have to think about blocks or threads at all. It&amp;rsquo;s nice!&lt;/p>
&lt;p>The drawback is that if you want to draw into a side buffer before compositing into a destination buffer, then you end up allocating the full &lt;code>size&lt;/code> and only use a block in the middle somewhere. Avoiding that is what &lt;code>stride&lt;/code> and &lt;code>offset&lt;/code> are for. Usually, you&amp;rsquo;d sample an individual pixel like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>sample := img.pixels[pos.x + pos.y*img.x];
&lt;/code>&lt;/pre>&lt;p>Instead, I do this:&lt;/p>
&lt;pre tabindex="0">&lt;code>sample := img.pixels[pos.x + pos.y*img.stride - img.offset];
&lt;/code>&lt;/pre>&lt;p>This way, you can sample an image by talking about coordinates in &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mo stretchy="false">[&lt;/mo>&lt;mn>0&lt;/mn>&lt;mo separator="true">,&lt;/mo>&lt;mn>1&lt;/mn>&lt;msup>&lt;mo stretchy="false">]&lt;/mo>&lt;mn>2&lt;/mn>&lt;/msup>&lt;/mrow>&lt;annotation encoding="application/x-tex">[0, 1]^2&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:1.064108em;vertical-align:-0.25em;">&lt;/span>&lt;span class="mopen">[&lt;/span>&lt;span class="mord">0&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="mord">1&lt;/span>&lt;span class="mclose">&lt;span class="mclose">]&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.8141079999999999em;">&lt;span style="top:-3.063em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mtight">2&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span> while the image only has storage allocated for &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mo stretchy="false">[&lt;/mo>&lt;mfrac>&lt;mn>3&lt;/mn>&lt;mn>8&lt;/mn>&lt;/mfrac>&lt;mo separator="true">,&lt;/mo>&lt;mfrac>&lt;mn>4&lt;/mn>&lt;mn>8&lt;/mn>&lt;/mfrac>&lt;msup>&lt;mo stretchy="false">]&lt;/mo>&lt;mn>2&lt;/mn>&lt;/msup>&lt;/mrow>&lt;annotation encoding="application/x-tex">[\frac{3}{8}, \frac{4}{8}]^2&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:1.190108em;vertical-align:-0.345em;">&lt;/span>&lt;span class="mopen">[&lt;/span>&lt;span class="mord">&lt;span class="mopen nulldelimiter">&lt;/span>&lt;span class="mfrac">&lt;span class="vlist-t vlist-t2">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.845108em;">&lt;span style="top:-2.6550000000000002em;">&lt;span class="pstrut" style="height:3em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mtight">&lt;span class="mord mtight">8&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span style="top:-3.23em;">&lt;span class="pstrut" style="height:3em;">&lt;/span>&lt;span class="frac-line" style="border-bottom-width:0.04em;">&lt;/span>&lt;/span>&lt;span style="top:-3.394em;">&lt;span class="pstrut" style="height:3em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mtight">&lt;span class="mord mtight">3&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="vlist-s">​&lt;/span>&lt;/span>&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.345em;">&lt;span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="mclose nulldelimiter">&lt;/span>&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="mord">&lt;span class="mopen nulldelimiter">&lt;/span>&lt;span class="mfrac">&lt;span class="vlist-t vlist-t2">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.845108em;">&lt;span style="top:-2.6550000000000002em;">&lt;span class="pstrut" style="height:3em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mtight">&lt;span class="mord mtight">8&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span style="top:-3.23em;">&lt;span class="pstrut" style="height:3em;">&lt;/span>&lt;span class="frac-line" style="border-bottom-width:0.04em;">&lt;/span>&lt;/span>&lt;span style="top:-3.394em;">&lt;span class="pstrut" style="height:3em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mtight">&lt;span class="mord mtight">4&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="vlist-s">​&lt;/span>&lt;/span>&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.345em;">&lt;span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="mclose nulldelimiter">&lt;/span>&lt;/span>&lt;span class="mclose">&lt;span class="mclose">]&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.8141079999999999em;">&lt;span style="top:-3.063em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mtight">2&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span> (for example), and all it takes is an extra subtraction.&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/p>
&lt;hr>
&lt;p>All the star colours are chosen by linearly interpolating between RGB values obtained by colour-picking from &lt;a href="https://en.wikipedia.org/wiki/Stellar_classification#/media/File:TernaryColorTmap.PNG">wikipedia&lt;/a>. They&amp;rsquo;re pretty close so I never had to do anything fancy involving splines or colour space transformations.&lt;/p>
&lt;hr>
&lt;p>Most of the look comes from blurring the entire image and layering the blurred and unblurred parts together in arbitrary ways. Think blend modes in image editors. It turns out it&amp;rsquo;s pretty easy to write a &lt;a href="https://fgiesen.wordpress.com/2012/07/30/fast-blurs-1/">fast&lt;/a> &lt;a href="https://fgiesen.wordpress.com/2012/08/01/fast-blurs-2/">blur&lt;/a>, and you don&amp;rsquo;t even have to think about how to vectorise it because everything is in 4 independent colour components already.&lt;/p>
&lt;p>The diffraction spikes are blurs, too. I think a lot of people jump to the fourier transform to do diffraction spikes but I couldn&amp;rsquo;t be bothered with that&amp;ndash;just take a box filter with a hole cut out of the middle and repeat it a few times. Same principle as using iterated box filters to approximate a gaussian blur, as in the links above, but non-separable this time, so you need to do vertical and horizontal passes both on the original image (i.e., not in series).&lt;/p>
&lt;p>If you look at actual diffraction spikes you can see different colours get diffracted more or less. I think this is probably the same principle as &lt;a href="https://en.wikipedia.org/wiki/Surface_wave#Ground_wave">ground waves&lt;/a>, where lower frequency radio waves diffract around the surface of the Earth more than higher frequency waves. So, I use different sizes of filter on each colour component; larger for larger wavelengths, I think, but you can only do so much in RGB.&lt;/p>
&lt;p>Honestly, though, the diffraction code is kind of terrible. Every time I think about it I think of a better way to implement it. For example, I haven&amp;rsquo;t vectorised it, because the memory accesses are different for each colour component. But to get diffractions at an angle I do a song and dance where I rotate a copy of the entire image to another buffer&amp;ndash;this would be a good time to rearrange the data into colour planes to make it vectorisable: multiple rows of a plane at once. I could even reuse the other blur code at that point, and implement the convolution &lt;code>(A - B)x&lt;/code> as &lt;code>Ax - Bx&lt;/code>. But I don&amp;rsquo;t! And I never will, now.&lt;/p>
&lt;hr>
&lt;p>The nebulas are a hot mess of noise functions, mostly &lt;a href="https://thebookofshaders.com/12/">cellular noise&lt;/a> with a healthy dose of &lt;a href="https://iquilezles.org/www/articles/warp/warp.htm">domain warping&lt;/a>. It all happens on a 2D plane; I didn&amp;rsquo;t want to think about 3D volumetric anything for this project.&lt;/p>
&lt;p>I do the cellular noise in fixed-point arithmetic. This was out of curiosity more anything else; the implementation comes pretty naturally from wanting to use a &lt;a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=madd&amp;amp;techs=SSE2&amp;amp;expand=3505">certain SSE2 instruction&lt;/a>. I&amp;rsquo;d like to write more about it, but not in this post.&lt;/p>
&lt;hr>
&lt;p>By the way, &lt;a href="https://glitch.com/">glitch&lt;/a> is pretty cool. It spins up an instance of who-knows-what for you and clang is just sitting there, waiting to compile whatever you want. A very old version of clang. That doesn&amp;rsquo;t have the intrinsics I use. Well, it has gcc, too.&lt;/p>
&lt;p>If you&amp;rsquo;ve scrolled all the way down here and only now have decided you want the bot&amp;rsquo;s twitter, &lt;a href="https://twitter.com/tiny_dso">here you go&lt;/a>.&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>Except &lt;a href="https://github.com/nothings/stb">stb_image_write.h&lt;/a> for the pngs. On Windows, I don&amp;rsquo;t write pngs, but render to a buffer managed by SDL. So they both have one dependency, but it&amp;rsquo;s a different dependency, I guess.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>I think most, if not all, of those bugs have been fixed in &lt;a href="https://github.com/uucidl/bitwise">this fork&lt;/a>.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>You could also shunt the &lt;code>pixels&lt;/code> pointer off into no-mans-land and pray you get all the new weird boundary conditions right.&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Calculating LOD</title><link>https://graemephi.github.io/posts/calculating-lod/</link><pubDate>Tue, 31 Dec 2019 13:29:00 +0000</pubDate><guid>https://graemephi.github.io/posts/calculating-lod/</guid><description>&lt;p>Angelo Pesce (@kenpex) recently tweeted:&lt;/p>
&lt;!-- https://twitter.com/kenpex/status/1201946673091448832 -->
&lt;blockquote class="twitter-tweet">&lt;p lang="en" dir="ltr">This is a calibration poll. Please don't spoil the answer, RT appreciated - Do you know how a GPU knows which mips to fetch when a regular tex2D(tex,uv) is called with trilinear filtering?&lt;/p>— c0de517e/AngeloPesce (@kenpex) &lt;a href="https://twitter.com/kenpex/status/1201946673091448832?ref_src=twsrc%5Etfw">December 3, 2019&lt;/a>&lt;/blockquote>
&lt;p>I would have counted myself as &amp;lsquo;not sure&amp;rsquo;, but I had a pretty good idea what it would involve and I was also pretty sure I could figure it out. Instead of just being pretty sure about it I decided to test my intuitions against a GPU and made &lt;a href="https://www.shadertoy.com/view/3ldGR2">this shadertoy&lt;/a>.&lt;/p>
&lt;p>Most of the code is machinery to get a triangle up that we can rotate around in 3D space. I find it vaguely amusing to write a triangle rasteriser in a fragment shader, so that&amp;rsquo;s what I did. This post is just about LOD, so if you&amp;rsquo;re interested in how the rasteriser works I recommend starting with Fabien Giesen&amp;rsquo;s &lt;a href="https://fgiesen.wordpress.com/2013/02/06/%5Dthe-barycentric-conspirac/">The Barycentric Conspiracy&lt;/a>.&lt;/p>
&lt;p>So, mipmaps: we have a texture with a series of successively smaller mip levels, each filtered properly prior to rendering to avoid aliasing. In this post I&amp;rsquo;m just going to assume textures are always square, and always a power of two in size. These restrictions can be lifted but I don&amp;rsquo;t really see why you would, except maybe to save space when using very large non-square textures.&lt;/p>
&lt;h2 id="2d">2D&lt;/h2>
&lt;p>I&amp;rsquo;d already done this in 2D for &lt;a href="https://github.com/graemephi/starfield">a small project of mine&lt;/a>, so this coloured my intuition a bit.&lt;/p>
&lt;img src="https://graemephi.github.io/posts/calculating-lod/6.png" width="502" height="532" />
&lt;p>I was just drawing textures in squares of different orientations and sizes&amp;ndash;it turns out an easy way to draw stars is to put a single very bright pixel in a big texture, and let mipmaps take care of the rest. So, here, we just have to do &lt;code>log2(texture_size / max(target_width, target_height))&lt;/code>, that is, the &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;msub>&lt;mo>&lt;mi>log&lt;/mi>&lt;mo>⁡&lt;/mo>&lt;/mo>&lt;mn>2&lt;/mn>&lt;/msub>&lt;/mrow>&lt;annotation encoding="application/x-tex">\log_2&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.93858em;vertical-align:-0.24414em;">&lt;/span>&lt;span class="mop">&lt;span class="mop">lo&lt;span style="margin-right:0.01389em;">g&lt;/span>&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t vlist-t2">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.20696799999999996em;">&lt;span style="top:-2.4558600000000004em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mtight">2&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="vlist-s">​&lt;/span>&lt;/span>&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.24414em;">&lt;span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span> of the inverse of the amount of scaling applied to the texture. To see why, each mip has &lt;em>relative&lt;/em> sizes &lt;code>1/1, 1/2, 1/4, ..., 1/n&lt;/code>. We can get the relative size of the target rect by looking at its width and height, and we want to turn that relative size into an index into this list of sizes for which we have mips. So, we need the function &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;msup>&lt;mn>2&lt;/mn>&lt;mrow>&lt;mo>−&lt;/mo>&lt;mi>n&lt;/mi>&lt;/mrow>&lt;/msup>&lt;mo>↦&lt;/mo>&lt;mo>−&lt;/mo>&lt;mi>n&lt;/mi>&lt;/mrow>&lt;annotation encoding="application/x-tex">2^{-n} \mapsto -n&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.782331em;vertical-align:-0.011em;">&lt;/span>&lt;span class="mord">&lt;span class="mord">2&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.771331em;">&lt;span style="top:-3.063em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mtight">&lt;span class="mord mtight">−&lt;/span>&lt;span class="mord mathdefault mtight">n&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="mspace" style="margin-right:0.2777777777777778em;">&lt;/span>&lt;span class="mrel">↦&lt;/span>&lt;span class="mspace" style="margin-right:0.2777777777777778em;">&lt;/span>&lt;/span>&lt;span class="base">&lt;span class="strut" style="height:0.66666em;vertical-align:-0.08333em;">&lt;/span>&lt;span class="mord">−&lt;/span>&lt;span class="mord mathdefault">n&lt;/span>&lt;/span>&lt;/span>&lt;/span>. That&amp;rsquo;s &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;msub>&lt;mo>&lt;mi>log&lt;/mi>&lt;mo>⁡&lt;/mo>&lt;/mo>&lt;mn>2&lt;/mn>&lt;/msub>&lt;/mrow>&lt;annotation encoding="application/x-tex">\log_2&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.93858em;vertical-align:-0.24414em;">&lt;/span>&lt;span class="mop">&lt;span class="mop">lo&lt;span style="margin-right:0.01389em;">g&lt;/span>&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t vlist-t2">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.20696799999999996em;">&lt;span style="top:-2.4558600000000004em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mtight">2&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="vlist-s">​&lt;/span>&lt;/span>&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.24414em;">&lt;span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>.&lt;/p>
&lt;p>Using &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;msub>&lt;mo>&lt;mi>log&lt;/mi>&lt;mo>⁡&lt;/mo>&lt;/mo>&lt;mn>2&lt;/mn>&lt;/msub>&lt;/mrow>&lt;annotation encoding="application/x-tex">\log_2&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.93858em;vertical-align:-0.24414em;">&lt;/span>&lt;span class="mop">&lt;span class="mop">lo&lt;span style="margin-right:0.01389em;">g&lt;/span>&lt;/span>&lt;span class="msupsub">&lt;span class="vlist-t vlist-t2">&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.20696799999999996em;">&lt;span style="top:-2.4558600000000004em;margin-right:0.05em;">&lt;span class="pstrut" style="height:2.7em;">&lt;/span>&lt;span class="sizing reset-size6 size3 mtight">&lt;span class="mord mtight">2&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="vlist-s">​&lt;/span>&lt;/span>&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.24414em;">&lt;span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span> also takes care of the fractional part of mip selection, so we can do trilinear filtering. If you think about it this is somewhat interesting, because we&amp;rsquo;re blending in a larger mip onto a target we already know is too small to not alias (in general). But having a jump discontuinity between mips looks way worse than low levels of aliasing.&lt;/p>
&lt;h2 id="3d">3D&lt;/h2>
&lt;p>The main thing about 3D is that the LOD level can change across the surface of a triangle.&lt;/p>
&lt;img src="https://graemephi.github.io/posts/calculating-lod/stoy.png" width="477" height="284" />
&lt;p>We need to think a bit more carefully about what&amp;rsquo;s happening. As we step along pixels in screen space, we also step along texels in texture space. While the former is constant, the latter steps vary in size due to perspective. Reasoning this way works in 2D, too, we just never had to: the constant, screen space step is our &lt;code>1&lt;/code> in the series of relative mip sizes, and the relative, texture space step size is the denominator up to &lt;code>n&lt;/code>. The question is how to get the step size at a given pixel, given that we shade each pixel independently of its neighbours. Now, I guess if you know the graphics pipeline quite well the answer to this jumps out at you, but I want to be able to justify why you would use the functions you do.&lt;/p>
&lt;p>So, in 2D, the texture space step size is constant, and we&amp;rsquo;re able to compute it by assuming we&amp;rsquo;re going to draw the entire texture and comparing its original size with its new width and height in screen space. Now, to get the step size at a point in 3D, we can approximate it by asking about a smaller part of the texture, say a 2x2 patch rather than the entire thing, at that point. To drive the point home here, in 2D we had&lt;/p>
&lt;p>&lt;span class="katex-display">&lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mfrac>&lt;mrow>&lt;mi>T&lt;/mi>&lt;mo stretchy="false">(&lt;/mo>&lt;mtext mathvariant="bold">0&lt;/mtext>&lt;mo>+&lt;/mo>&lt;mtext mathvariant="bold">x&lt;/mtext>&lt;mo stretchy="false">)&lt;/mo>&lt;mo>−&lt;/mo>&lt;mi>T&lt;/mi>&lt;mo stretchy="false">(&lt;/mo>&lt;mtext mathvariant="bold">0&lt;/mtext>&lt;mo stretchy="false">)&lt;/mo>&lt;/mrow>&lt;mrow>&lt;mo fence="true">∥&lt;/mo>&lt;mtext mathvariant="bold">x&lt;/mtext>&lt;mo fence="true">∥&lt;/mo>&lt;/mrow>&lt;/mfrac>&lt;/mrow>&lt;annotation encoding="application/x-tex"> \frac{ T(\textbf{0} + \textbf{x} ) - T(\textbf{0}) }{ \left\| \textbf{x} \right\| }&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:2.363em;vertical-align:-0.936em;">&lt;/span>&lt;span class="mord">&lt;span class="mopen nulldelimiter">&lt;/span>&lt;span class="mfrac">&lt;span class="vlist-t vlist-t2">&lt;span class="vlist-r">&lt;span class="vlist" style="height:1.427em;">&lt;span style="top:-2.314em;">&lt;span class="pstrut" style="height:3em;">&lt;/span>&lt;span class="mord">&lt;span class="minner">&lt;span class="mopen delimcenter" style="top:0em;">∥&lt;/span>&lt;span class="mord text">&lt;span class="mord textbf">x&lt;/span>&lt;/span>&lt;span class="mclose delimcenter" style="top:0em;">∥&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span style="top:-3.23em;">&lt;span class="pstrut" style="height:3em;">&lt;/span>&lt;span class="frac-line" style="border-bottom-width:0.04em;">&lt;/span>&lt;/span>&lt;span style="top:-3.677em;">&lt;span class="pstrut" style="height:3em;">&lt;/span>&lt;span class="mord">&lt;span class="mord mathdefault" style="margin-right:0.13889em;">T&lt;/span>&lt;span class="mopen">(&lt;/span>&lt;span class="mord text">&lt;span class="mord textbf">0&lt;/span>&lt;/span>&lt;span class="mspace" style="margin-right:0.2222222222222222em;">&lt;/span>&lt;span class="mbin">+&lt;/span>&lt;span class="mspace" style="margin-right:0.2222222222222222em;">&lt;/span>&lt;span class="mord text">&lt;span class="mord textbf">x&lt;/span>&lt;/span>&lt;span class="mclose">)&lt;/span>&lt;span class="mspace" style="margin-right:0.2222222222222222em;">&lt;/span>&lt;span class="mbin">−&lt;/span>&lt;span class="mspace" style="margin-right:0.2222222222222222em;">&lt;/span>&lt;span class="mord mathdefault" style="margin-right:0.13889em;">T&lt;/span>&lt;span class="mopen">(&lt;/span>&lt;span class="mord text">&lt;span class="mord textbf">0&lt;/span>&lt;/span>&lt;span class="mclose">)&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="vlist-s">​&lt;/span>&lt;/span>&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.936em;">&lt;span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="mclose nulldelimiter">&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/p>
&lt;p>with &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mi>T&lt;/mi>&lt;/mrow>&lt;annotation encoding="application/x-tex">T&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.68333em;vertical-align:0em;">&lt;/span>&lt;span class="mord mathdefault" style="margin-right:0.13889em;">T&lt;/span>&lt;/span>&lt;/span>&lt;/span> being some transform and &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mtext mathvariant="bold">x&lt;/mtext>&lt;/mrow>&lt;annotation encoding="application/x-tex">\textbf{x}&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.44444em;vertical-align:0em;">&lt;/span>&lt;span class="mord text">&lt;span class="mord textbf">x&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span> being one side of the texture, and we&amp;rsquo;re replacing it with&lt;/p>
&lt;p>&lt;span class="katex-display">&lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mfrac>&lt;mrow>&lt;mi>T&lt;/mi>&lt;mo stretchy="false">(&lt;/mo>&lt;mtext mathvariant="bold">p&lt;/mtext>&lt;mo>+&lt;/mo>&lt;mi>h&lt;/mi>&lt;mtext mathvariant="bold">x&lt;/mtext>&lt;mo stretchy="false">)&lt;/mo>&lt;mo>−&lt;/mo>&lt;mi>T&lt;/mi>&lt;mo stretchy="false">(&lt;/mo>&lt;mtext mathvariant="bold">p&lt;/mtext>&lt;mo stretchy="false">)&lt;/mo>&lt;/mrow>&lt;mrow>&lt;mi>h&lt;/mi>&lt;mrow>&lt;mo fence="true">∥&lt;/mo>&lt;mtext mathvariant="bold">x&lt;/mtext>&lt;mo fence="true">∥&lt;/mo>&lt;/mrow>&lt;/mrow>&lt;/mfrac>&lt;/mrow>&lt;annotation encoding="application/x-tex"> \frac{ T(\textbf{p} + h\textbf{x} ) - T(\textbf{p}) }{ h\left\| \textbf{x} \right\| }&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:2.363em;vertical-align:-0.936em;">&lt;/span>&lt;span class="mord">&lt;span class="mopen nulldelimiter">&lt;/span>&lt;span class="mfrac">&lt;span class="vlist-t vlist-t2">&lt;span class="vlist-r">&lt;span class="vlist" style="height:1.427em;">&lt;span style="top:-2.314em;">&lt;span class="pstrut" style="height:3em;">&lt;/span>&lt;span class="mord">&lt;span class="mord mathdefault">h&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="minner">&lt;span class="mopen delimcenter" style="top:0em;">∥&lt;/span>&lt;span class="mord text">&lt;span class="mord textbf">x&lt;/span>&lt;/span>&lt;span class="mclose delimcenter" style="top:0em;">∥&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span style="top:-3.23em;">&lt;span class="pstrut" style="height:3em;">&lt;/span>&lt;span class="frac-line" style="border-bottom-width:0.04em;">&lt;/span>&lt;/span>&lt;span style="top:-3.677em;">&lt;span class="pstrut" style="height:3em;">&lt;/span>&lt;span class="mord">&lt;span class="mord mathdefault" style="margin-right:0.13889em;">T&lt;/span>&lt;span class="mopen">(&lt;/span>&lt;span class="mord text">&lt;span class="mord textbf">p&lt;/span>&lt;/span>&lt;span class="mspace" style="margin-right:0.2222222222222222em;">&lt;/span>&lt;span class="mbin">+&lt;/span>&lt;span class="mspace" style="margin-right:0.2222222222222222em;">&lt;/span>&lt;span class="mord mathdefault">h&lt;/span>&lt;span class="mord text">&lt;span class="mord textbf">x&lt;/span>&lt;/span>&lt;span class="mclose">)&lt;/span>&lt;span class="mspace" style="margin-right:0.2222222222222222em;">&lt;/span>&lt;span class="mbin">−&lt;/span>&lt;span class="mspace" style="margin-right:0.2222222222222222em;">&lt;/span>&lt;span class="mord mathdefault" style="margin-right:0.13889em;">T&lt;/span>&lt;span class="mopen">(&lt;/span>&lt;span class="mord text">&lt;span class="mord textbf">p&lt;/span>&lt;/span>&lt;span class="mclose">)&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="vlist-s">​&lt;/span>&lt;/span>&lt;span class="vlist-r">&lt;span class="vlist" style="height:0.936em;">&lt;span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;span class="mclose nulldelimiter">&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/span>&lt;/p>
&lt;p>and making &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mi>h&lt;/mi>&lt;/mrow>&lt;annotation encoding="application/x-tex">h&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.69444em;vertical-align:0em;">&lt;/span>&lt;span class="mord mathdefault">h&lt;/span>&lt;/span>&lt;/span>&lt;/span> really small. So, we need two of these for the derivatives in &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mi>x&lt;/mi>&lt;/mrow>&lt;annotation encoding="application/x-tex">x&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.43056em;vertical-align:0em;">&lt;/span>&lt;span class="mord mathdefault">x&lt;/span>&lt;/span>&lt;/span>&lt;/span> and &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mi>y&lt;/mi>&lt;/mrow>&lt;annotation encoding="application/x-tex">y&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.625em;vertical-align:-0.19444em;">&lt;/span>&lt;span class="mord mathdefault" style="margin-right:0.03588em;">y&lt;/span>&lt;/span>&lt;/span>&lt;/span>, and you can get an approximation of them&amp;ndash;basically this same one here&amp;ndash;in OpenGL with &lt;code>dFdx()&lt;/code> and &lt;code>dFdy()&lt;/code>.&lt;/p>
&lt;p>In the shadertoy, this is all implemented like this.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-glsl" data-lang="glsl">&lt;span style="color:#75715e">// uv comes in as an interpolated input&lt;/span>
&lt;span style="color:#66d9ef">vec2&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">vec2&lt;/span>(textureSize(iChannel0, &lt;span style="color:#ae81ff">0&lt;/span>));
&lt;span style="color:#66d9ef">vec2&lt;/span> dx &lt;span style="color:#f92672">=&lt;/span> dFdx(uv &lt;span style="color:#f92672">*&lt;/span> size);
&lt;span style="color:#66d9ef">vec2&lt;/span> dy &lt;span style="color:#f92672">=&lt;/span> dFdy(uv &lt;span style="color:#f92672">*&lt;/span> size);
&lt;span style="color:#66d9ef">float&lt;/span> d &lt;span style="color:#f92672">=&lt;/span> max(length(dx), length(dy));
&lt;span style="color:#66d9ef">float&lt;/span> lod &lt;span style="color:#f92672">=&lt;/span> max(&lt;span style="color:#ae81ff">0.&lt;/span>, log2(d));
&lt;span style="color:#66d9ef">vec3&lt;/span> col &lt;span style="color:#f92672">=&lt;/span> textureLod(tex, p, lod).xyz;&lt;/code>&lt;/pre>&lt;/div>
&lt;p>Eyeballing the results this seems to work, but if we take the difference between &lt;code>textureLod()&lt;/code> with our &lt;code>lod&lt;/code> value versus using &lt;code>texture()&lt;/code> and scale it up a bit to magnify errors, we get this.&lt;/p>
&lt;img src="https://graemephi.github.io/posts/calculating-lod/stoy2.png" width="477" height="284" />
&lt;p>It should be black. The problem is obvious in retrospect, but rather than thinking too hard about it I had a look through the &lt;a href="https://microsoft.github.io/DirectX-Specs/d3d/archive/D3D11_3_FunctionalSpec.htm#LODCalculation">DX11 Functional Specification&lt;/a>, which tells you to do this to the derivative vectors:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-glsl" data-lang="glsl">&lt;span style="color:#66d9ef">float&lt;/span> A &lt;span style="color:#f92672">=&lt;/span> dx.y &lt;span style="color:#f92672">*&lt;/span> dx.y &lt;span style="color:#f92672">+&lt;/span> dy.y &lt;span style="color:#f92672">*&lt;/span> dy.y;
&lt;span style="color:#66d9ef">float&lt;/span> B &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2.0&lt;/span> &lt;span style="color:#f92672">*&lt;/span> (dx.x &lt;span style="color:#f92672">*&lt;/span> dx.y &lt;span style="color:#f92672">+&lt;/span> dy.x &lt;span style="color:#f92672">*&lt;/span> dy.y);
&lt;span style="color:#66d9ef">float&lt;/span> C &lt;span style="color:#f92672">=&lt;/span> dx.x &lt;span style="color:#f92672">*&lt;/span> dx.x &lt;span style="color:#f92672">+&lt;/span> dy.x &lt;span style="color:#f92672">*&lt;/span> dy.x;
&lt;span style="color:#66d9ef">float&lt;/span> F &lt;span style="color:#f92672">=&lt;/span> dx.x &lt;span style="color:#f92672">*&lt;/span> dy.y &lt;span style="color:#f92672">-&lt;/span> dy.x &lt;span style="color:#f92672">*&lt;/span> dx.y;
F &lt;span style="color:#f92672">=&lt;/span> F&lt;span style="color:#f92672">*&lt;/span>F;
&lt;span style="color:#66d9ef">float&lt;/span> p &lt;span style="color:#f92672">=&lt;/span> A &lt;span style="color:#f92672">-&lt;/span> C;
&lt;span style="color:#66d9ef">float&lt;/span> q &lt;span style="color:#f92672">=&lt;/span> A &lt;span style="color:#f92672">+&lt;/span> C;
&lt;span style="color:#66d9ef">float&lt;/span> t &lt;span style="color:#f92672">=&lt;/span> sqrt(p&lt;span style="color:#f92672">*&lt;/span>p &lt;span style="color:#f92672">+&lt;/span> B&lt;span style="color:#f92672">*&lt;/span>B);
dx.x &lt;span style="color:#f92672">=&lt;/span> sqrt(F &lt;span style="color:#f92672">*&lt;/span> (t&lt;span style="color:#f92672">+&lt;/span>p) &lt;span style="color:#f92672">/&lt;/span> (t &lt;span style="color:#f92672">*&lt;/span> (q&lt;span style="color:#f92672">+&lt;/span>t)));
dx.y &lt;span style="color:#f92672">=&lt;/span> sqrt(F &lt;span style="color:#f92672">*&lt;/span> (t&lt;span style="color:#f92672">-&lt;/span>p) &lt;span style="color:#f92672">/&lt;/span> (t &lt;span style="color:#f92672">*&lt;/span> (q&lt;span style="color:#f92672">+&lt;/span>t))) &lt;span style="color:#f92672">*&lt;/span> sign(B);
dy.x &lt;span style="color:#f92672">=&lt;/span> sqrt(F &lt;span style="color:#f92672">*&lt;/span> (t&lt;span style="color:#f92672">-&lt;/span>p) &lt;span style="color:#f92672">/&lt;/span> (t &lt;span style="color:#f92672">*&lt;/span> (q&lt;span style="color:#f92672">-&lt;/span>t))) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#f92672">-&lt;/span>sign(B);
dy.y &lt;span style="color:#f92672">=&lt;/span> sqrt(F &lt;span style="color:#f92672">*&lt;/span> (t&lt;span style="color:#f92672">+&lt;/span>p) &lt;span style="color:#f92672">/&lt;/span> (t &lt;span style="color:#f92672">*&lt;/span> (q&lt;span style="color:#f92672">-&lt;/span>t)));&lt;/code>&lt;/pre>&lt;/div>
&lt;h2 id="ellipses">Ellipses&lt;/h2>
&lt;p>The source it references only as [Heckbert 89] turns out to be a master&amp;rsquo;s thesis, &lt;em>Fundamentals of Texture Mapping and Image Warping&lt;/em>, which includes this in its appendices. The DX11 spec says it gives you a &amp;ldquo;proper orthogonal Jacobian matrix&amp;rdquo;, where proper is not a technical term. So, this is looking at the projection as a 2D transform from a point &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mo stretchy="false">(&lt;/mo>&lt;mi>x&lt;/mi>&lt;mo separator="true">,&lt;/mo>&lt;mi>y&lt;/mi>&lt;mo stretchy="false">)&lt;/mo>&lt;/mrow>&lt;annotation encoding="application/x-tex">(x, y)&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:1em;vertical-align:-0.25em;">&lt;/span>&lt;span class="mopen">(&lt;/span>&lt;span class="mord mathdefault">x&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="mord mathdefault" style="margin-right:0.03588em;">y&lt;/span>&lt;span class="mclose">)&lt;/span>&lt;/span>&lt;/span>&lt;/span> in screen space to a point &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mo stretchy="false">(&lt;/mo>&lt;mi>u&lt;/mi>&lt;mo separator="true">,&lt;/mo>&lt;mi>v&lt;/mi>&lt;mo stretchy="false">)&lt;/mo>&lt;/mrow>&lt;annotation encoding="application/x-tex">(u, v)&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:1em;vertical-align:-0.25em;">&lt;/span>&lt;span class="mopen">(&lt;/span>&lt;span class="mord mathdefault">u&lt;/span>&lt;span class="mpunct">,&lt;/span>&lt;span class="mspace" style="margin-right:0.16666666666666666em;">&lt;/span>&lt;span class="mord mathdefault" style="margin-right:0.03588em;">v&lt;/span>&lt;span class="mclose">)&lt;/span>&lt;/span>&lt;/span>&lt;/span> in texture space. Now, it&amp;rsquo;s not linear, so you can&amp;rsquo;t represent it with a 2x2 matrix, but you can look at its derivative to get a linear approximation at a point. That&amp;rsquo;s the Jacobian, and we can construct it by just putting our derivative vectors in the columns of a matrix. But this Jacobian won&amp;rsquo;t be proper.&lt;/p>
&lt;p>Basically, the issue is that up until now I&amp;rsquo;ve been neglecting to consider off-axis scaling. To solve this, we want to look at how the unit circle is transformed, not just the axes. That is, we look at the ellipse formed by applying the Jacobian to the unit circle. Weirdly, a pretty good explanation of this idea can be found in the Wikipedia article on &lt;a href="https://en.wikipedia.org/wiki/Singular_value_decomposition#Intuitive_interpretations">singular value decomposition&lt;/a>. Anyway, here&amp;rsquo;s &lt;a href="https://www.shadertoy.com/view/ttc3DX">a shadertoy&lt;/a> showing how the above code modifies the axes:&lt;/p>
&lt;img src="https://graemephi.github.io/posts/calculating-lod/ellipse.png" width="640" height="360" />
&lt;p>The right ellipse&amp;rsquo;s axes have been obtained by orthogonalising those on the left. The important thing is that both pairs of axes describe the same ellipse. The reason I went through the effort of creating that shadertoy, though, is because I wanted to check that putting those axes into the columns of two matrices would actually give you matrices that created the same ellipse. Because it&amp;rsquo;s a completely different transform, right, one of them isn&amp;rsquo;t even orthogonal! Of course, it does give you the same ellipse, and I guess the reason why that&amp;rsquo;s possible is obvious: each point on the plane is sent to a different place in either matrix, but the &lt;em>unit circle&lt;/em> traces out the same ellipse for both. To that end, I&amp;rsquo;ve coloured each point by its original position inside the unit circle.&lt;/p>
&lt;p>What this gives you is the maximum scaling in all directions, not just the directions the texture&amp;rsquo;s &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mi>x&lt;/mi>&lt;/mrow>&lt;annotation encoding="application/x-tex">x&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.43056em;vertical-align:0em;">&lt;/span>&lt;span class="mord mathdefault">x&lt;/span>&lt;/span>&lt;/span>&lt;/span> and &lt;span class="katex">&lt;span class="katex-mathml">&lt;math xmlns="http://www.w3.org/1998/Math/MathML">&lt;semantics>&lt;mrow>&lt;mi>y&lt;/mi>&lt;/mrow>&lt;annotation encoding="application/x-tex">y&lt;/annotation>&lt;/semantics>&lt;/math>&lt;/span>&lt;span class="katex-html" aria-hidden="true">&lt;span class="base">&lt;span class="strut" style="height:0.625em;vertical-align:-0.19444em;">&lt;/span>&lt;span class="mord mathdefault" style="margin-right:0.03588em;">y&lt;/span>&lt;/span>&lt;/span>&lt;/span> axes have been mapped to in screen space.&lt;/p>
&lt;p>Now, applying that correction, we&amp;rsquo;re much closer:&lt;/p>
&lt;img src="https://graemephi.github.io/posts/calculating-lod/stoy3.png" width="477" height="284" />
&lt;p>Still not perfect, though. I&amp;rsquo;m not sure what&amp;rsquo;s missing. DX11 allows for approximations here, and OpenGL&amp;rsquo;s specification doesn&amp;rsquo;t really say anything at all about it, so maybe that&amp;rsquo;s it. I&amp;rsquo;m really not sure.&lt;/p>
&lt;h2 id="blocks">Blocks&lt;/h2>
&lt;p>Finally, when I first wrote the rasteriser I did it the natural way, something like&lt;/p>
&lt;pre tabindex="0">&lt;code>if (inside_triangle) {
color = calculate_color()
write_pixel(color)
}
&lt;/code>&lt;/pre>&lt;p>But if you look at the shadertoy now, you&amp;rsquo;ll see it&amp;rsquo;s written as&lt;/p>
&lt;pre tabindex="0">&lt;code>color = calculate_color()
if (inside_triangle) {
write_pixel(color)
}
&lt;/code>&lt;/pre>&lt;p>which looks like it wastes a bunch of effort colouring pixels it never writes. The reason for this is that the &lt;code>dFdx&lt;/code> and &lt;code>dFdy&lt;/code> functions aren&amp;rsquo;t magic: they really do take an approximation of the derivative by subtracting neighbouring pixel values from each other in 2x2 blocks. Since we&amp;rsquo;re running the shader in parallel for each pixel in the block, different pixels in the block can branch in different directions. At that point, the GPU is missing neighbouring values for &lt;code>dFdx&lt;/code>/&lt;code>dFdy&lt;/code> to compute derivatives with. The derivative computation breaks down and we can&amp;rsquo;t sample mipmaps at all. On my machine, this gave a LOD value of &lt;code>0&lt;/code> which resulted in a seam of aliasing down the edges of triangles. At first I thought this was a bug in the inclusion test, but no, it&amp;rsquo;s just old fashioned &lt;a href="https://www.khronos.org/opengl/wiki/Non-Uniform_Control_Flow#Non-uniform_flow_control">non-uniform flow control&lt;/a>.&lt;/p>
&lt;h2 id="end">End&lt;/h2>
&lt;p>I&amp;rsquo;m kinda disappointed I wasn&amp;rsquo;t able to get the LOD computation exact even after going through DX11 and OpenGL specifications. And it &lt;em>is&lt;/em> just the LOD that&amp;rsquo;s wrong&amp;ndash;with fixed LOD, the rasteriser does trilinear filtering down to &lt;code>texelFetch()&lt;/code> just fine. Also, I&amp;rsquo;ve not talked about anisotropic filtering at all, which I&amp;rsquo;ve now discovered I know even less about than I thought I did. I&amp;rsquo;d like to know more about how it&amp;rsquo;s implemented on GPUs but it appears to be like, a trade secret, or something.&lt;/p>
&lt;p>I think writing this post took longer than writing the shadertoy.&lt;/p></description></item></channel></rss>